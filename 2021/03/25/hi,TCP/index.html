

<!DOCTYPE html>
<html lang="zh-CN" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>hi,TCP - ztranscript</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="TCP前言不管是前端还是后端，TCP（或者说计网）的知...">
  <meta name="author" content="ztranscript">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: true,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '[object Object]',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar" style="">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">hi,TCP</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">hi,TCP</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>三月 25, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>7298</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管是前端还是后端，TCP（或者说计网）的知识点都是必问的了。<br></p>
<p>可向来计网的知识，就是那么晦涩，一下子想要弄懂属实困难。<br></p>
<p>不过，饭要一口口吃，路要一步步走。这里我从网上收集到的一些 TCP 相关面试题型，来讨论一下这个难搞的 TCP。</p>
<p>先来看看这篇文章的关注点。<strong>上图！</strong>（图片来自网络）</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224438130.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325205500549</span></p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224440303.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325205448579</span></p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224439286.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325205507472</span></p>
<p>这篇文章打算从上述几个方面来整理一下相关知识点。</p>
<h2 id="01-TCP-基本认识"><a href="#01-TCP-基本认识" class="headerlink" title="01 TCP 基本认识"></a>01 TCP 基本认识</h2><p>先来看看 TCP 头的格式</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224802109.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325205718199</span></p>
<p><strong>序列号</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">用来标识从TCP 源端向TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。<br><br>如果将字节流看作在两个应用程序间的单向流动，则TCP 用顺序号对每个字节进行计数。<br><br>序号是32bit 的无符号数，序号到达2 的32次方－1 后又从0 开始。<br><br>当建立一个新的连接时，SYN 标志变1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号ISN （Initial Sequence Number ）。<br></code></pre></td></tr></table></figure>



<p><strong>确认应答号</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">包含发送确认的一端所期望收到的下一个顺序号。<br><br>因此，确认序号应当是上次已成功收到数据字节顺序号加1 。<br>只有ACK 标志为1 时确认序号字段才有效。<br><br>TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。<br>因此，连接的每一端必须保持每个方向上的传输数据顺序号。<br></code></pre></td></tr></table></figure>



<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYC</em>：该位为 <code>1</code> 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li>
</ul>
<h4 id="Q：为什么需要-TCP-协议？TCP-工作在哪一层？"><a href="#Q：为什么需要-TCP-协议？TCP-工作在哪一层？" class="headerlink" title="Q：为什么需要 TCP 协议？TCP 工作在哪一层？"></a>Q：为什么需要 TCP 协议？TCP 工作在哪一层？</h4><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>如果需要保障网络数据包的可靠性，那么就得由上层（运输层）的 <strong>TCP</strong> 协议来负责。</p>
<p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<h4 id="Q：什么是-TCP-？"><a href="#Q：什么是-TCP-？" class="headerlink" title="Q：什么是 TCP ？"></a>Q：什么是 TCP ？</h4><p>TCP 是一个 面向连接、可靠的、基于字节流 的传输层协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
<h4 id="Q：什么是-TCP-连接？"><a href="#Q：什么是-TCP-连接？" class="headerlink" title="Q：什么是 TCP 连接？"></a>Q：什么是 TCP 连接？</h4><p>TCP连接，简单来说就是，用于保证 可靠性 和 流量控制 维护的某些状态信息，这些信息的组合，包括SOcket、序列号和窗口大小。</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
<h4 id="Q：如何唯一确定一个-TCP-连接呢？"><a href="#Q：如何唯一确定一个-TCP-连接呢？" class="headerlink" title="Q：如何唯一确定一个 TCP 连接呢？"></a>Q：如何唯一确定一个 TCP 连接呢？</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址 （32位）</li>
<li>源端口 （16位）</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<h4 id="Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h4><p>服务器常常固定在某个本地端口上监听，等待客户端的连接。</p>
<p>因为客户端的IP 和 客户端的端口数是可变的，于是有：</p>
<p><code>最大TCP连接数 = 客户端IP数 * 客户端的端口数</code></p>
<p>对于 IPv4 而言，Max = 2^32 * 2^16  =&gt; 2^48</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。它会受到<strong>文件描述符</strong>的限制（Socket都是文件） 以及 服务器操作系统的 <strong>内存限制</strong>。</p>
<h4 id="Q：UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#Q：UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="Q：UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>Q：UDP 和 TCP 有什么区别呢？分别的应用场景是？</h4><p>先来看看 UDP 的头部格式。</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224439431.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325211540311</span></p>
<ul>
<li><p>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</p>
</li>
<li><p>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</p>
</li>
<li><p>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</p>
</li>
</ul>
<h5 id="TCP-和-UDP-区别："><a href="#TCP-和-UDP-区别：" class="headerlink" title="TCP 和 UDP 区别："></a><strong>TCP 和 UDP 区别：</strong></h5><ol>
<li><p>TCP 是面向连接的传输层协议，数据传输之前需要建立连接；而UDP不必。</p>
</li>
<li><p>TCP 是一对一的两点服务；而UDP支持一对一、一对多、多对多的交互通信。</p>
</li>
<li><p>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达；而 UDP 是尽最大努力进行交付，不保证可靠性。</p>
</li>
<li><p>TCP 有拥塞控制 和 流量控制，保证数据的安全性；UDP则没有。</p>
</li>
<li><p>TCP 首部开销大，首部为 20字节（固定位）+ 可选位；UDP首部只有 8 个字节。</p>
</li>
<li><p>TCP 需要建立连接，所以它的传输速率较低；UDP速率较高。</p>
</li>
</ol>
<h5 id="TCP-和-UDP-应用场景："><a href="#TCP-和-UDP-应用场景：" class="headerlink" title="TCP 和 UDP 应用场景："></a><strong>TCP 和 UDP 应用场景：</strong></h5><p>TCP：面向连接，能保证数据的安全交付</p>
<ul>
<li><code>FTP</code> 文件传输</li>
<li><code>HTTP</code> / <code>HTTPS</code></li>
</ul>
<p>UDP：面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<h4 id="Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h4><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<h4 id="Q：为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？"><a href="#Q：为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？" class="headerlink" title="Q：为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？"></a>Q：为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</h4><p>TCP 和 UDP都是基于 IP协议的，也就是说：TCP计算负载（数据部分）长度的公式对于UDP依然适用。</p>
<p>TCP 计算负载长度：</p>
<ul>
<li>TCP负载长度 = IP总长度-IP首部长度-TCP首部长度</li>
</ul>
<p>这么一看，UDP的「包长度」倒有点多余。不过我们知道，<strong>为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。</strong></p>
<p>所以我们可以猜想，增加这个字段或许是为了使得 UDP 首部长度为 4字节的整数倍。</p>
<h2 id="02-TCP-连接建立"><a href="#02-TCP-连接建立" class="headerlink" title="02 TCP 连接建立"></a>02 TCP 连接建立</h2><h4 id="Q：TCP-三次握手过程和状态变迁"><a href="#Q：TCP-三次握手过程和状态变迁" class="headerlink" title="Q：TCP 三次握手过程和状态变迁"></a>Q：TCP 三次握手过程和状态变迁</h4><p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224439752.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325212943480</span></p>
<p><strong>第一次握手：</strong></p>
<p>A 发送 同步码 SYN = 1，随机产生 seq = x的数据包到服务器，主机B由 SYN = 1知道，A想要建立连接。</p>
<p><strong>第二次握手：</strong></p>
<p>主机B收到请求后要确认联机信息，向A发送 ack = x+1（即上次的seq+1），随机产生seq = y，并同步码SYN = 1，确认码ACK = 1的数据包来响应A的请求。</p>
<p><strong>第三次握手：</strong></p>
<p>主机A检查 ack 是否正确（是否为x+1），以及确认码 ACK 是否为1。若正确，主机A发送ack = y+1（即上次的seq+1），ACK = 1。主机B收到后确认ack 和 ACK位正确后，则连接建立成功。</p>
<h4 id="Q：为什么是三次握手？不是两次、四次？"><a href="#Q：为什么是三次握手？不是两次、四次？" class="headerlink" title="Q：为什么是三次握手？不是两次、四次？"></a>Q：为什么是三次握手？不是两次、四次？</h4><p>我们来看看上面的三次握手的过程中，AB主机都知道些什么。<br></p>
<p><strong>第一次握手：</strong></p>
<p>主机B能知道（A发送正常，B接收正常）；主机A啥都不能知道。</p>
<p><strong>第二次握手：</strong></p>
<p>主机B知道（A发送正常，B接收正常）；主机A知道（A发送正常、接收正常，B发送正常、接收正常）。</p>
<p><strong>第三次握手：</strong></p>
<p>主机B收到A的确认，知道自己的发送功能正常。由此，AB双方的收发都已正常（也被对方知晓）。</p>
<p><strong>为什么不是四次？</strong>回答：三次已然能够通信连接的建立，为了节省资源，没有必要多加一次握手。</p>
<p><strong>至于为啥不能是两次？</strong>回答：主要是由于网络的不确定性，一是无法让双方都知晓对方与自己的收发能力，而是<strong>为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>至于原因，看这里：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：<br><br>- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；<br>- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；<br>- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。<br><br>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：<br><br>- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；<br>- 如果不是历史连接，则第三次发送的报文是 `ACK` 报文，通信双方就会成功建立连接；<br><br>所以， TCP 使用三次握手建立连接的最主要原因是**防止历史连接初始化了连接。**<br></code></pre></td></tr></table></figure>



<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h4 id="Q：为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#Q：为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="Q：为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a>Q：为什么客户端和服务端的初始序列号 ISN 是不相同的？</h4><p>因为网络中的报文<strong>会延迟、会复制重发、也有可能丢失</strong>，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p>
<h4 id="Q：初始序列号-ISN-是如何随机产生的？"><a href="#Q：初始序列号-ISN-是如何随机产生的？" class="headerlink" title="Q：初始序列号 ISN 是如何随机产生的？"></a>Q：初始序列号 ISN 是如何随机产生的？</h4><p>起始 <code>ISN</code> 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。</p>
<p><em>ISN = M + F (localhost, localport, remotehost, remoteport)</em></p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 毫秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<h4 id="Q：既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#Q：既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="Q：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>Q：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><p>我们先来认识下 MTU 和 MSS</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224446562.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325214941433</span></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p><strong>当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为IP层是没有重传机制的，它得靠上层传输层来负责超时 和 重传。</p>
<p><strong>举个例子：</strong></p>
<p>发送方：TCP不分片有 X 字节的数据，它被IP层分为 Y 片。</p>
<p>接收方：收到Y-1个 IP 分片，交由这边的传输层会导致将X字节的数据全部重传。</p>
<p>由此可见，这样是非常没有效率的。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>。</p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h4 id="Q：什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#Q：什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="Q：什么是 SYN 攻击？如何避免 SYN 攻击？"></a>Q：什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p><em>SYN 攻击</em></p>
<p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224451434.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325215655477</span></p>
<p>— 至于避免SYN攻击的手段，这里暂时没有整理好答案，先放着。—</p>
<h2 id="03-TCP-连接断开"><a href="#03-TCP-连接断开" class="headerlink" title="03 TCP 连接断开"></a>03 TCP 连接断开</h2><h4 id="Q：TCP-四次挥手过程和状态变迁"><a href="#Q：TCP-四次挥手过程和状态变迁" class="headerlink" title="Q：TCP 四次挥手过程和状态变迁"></a>Q：TCP 四次挥手过程和状态变迁</h4><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥手</strong>方式。</p>
<p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p><img    class="lazyload" data-original="https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210325224449769.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image-20210325215857136</span></p>
<p><strong>第一次挥手：</strong></p>
<p>主机A发送FIN后，进入终止等待状态。</p>
<p><strong>第二次挥手：</strong></p>
<p>服务器B收到主机A连接释放报文段后，就立即给主机A发送确认，然后服务器B就进入close-wait状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。</p>
<p><strong>第三次挥手：</strong></p>
<p>此时，若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。</p>
<p><strong>第四次挥手：</strong></p>
<p>A发送确认后，进入time-wait，注意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。</p>
<p>简单的说：A（先断开连接的一方）关闭A-&gt;B这一边的连接通道；再B处理完数据后，向A发送关闭请求，关闭B-&gt;A这一边的连接通道。</p>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="Q：为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#Q：为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="Q：为什么 TIME_WAIT 等待的时间是 2MSL？"></a>Q：为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p>先来了解两个概念：MSL 和 TTL。</p>
<p><strong>MSL：</strong>Maximum Segment Lifetime，<strong>报文最大生存时间</strong></p>
<p><strong>TTL：</strong>IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<h4 id="Q：为什么需要-TIME-WAIT-状态？"><a href="#Q：为什么需要-TIME-WAIT-状态？" class="headerlink" title="Q：为什么需要 TIME_WAIT 状态？"></a>Q：为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li><p>防止具有相同「四元组」的「旧」数据包被收到；</p>
</li>
<li><p>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</p>
</li>
</ul>
<p><em>原因一：防止旧连接的数据包</em></p>
<p>经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证连接正确关闭</em></p>
<p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<h4 id="Q：TIME-WAIT-过多有什么危害？"><a href="#Q：TIME-WAIT-过多有什么危害？" class="headerlink" title="Q：TIME_WAIT 过多有什么危害？"></a>Q：TIME_WAIT 过多有什么危害？</h4><ul>
<li>第一是内存资源占用；</li>
<li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li>
</ul>
<h4 id="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<br><br>每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，<br><br>如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。<br></code></pre></td></tr></table></figure>

<p>对于TCP 保活机制，有以下几点需要注意：</p>
<p>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
<p>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</p>
<p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
<p>哈哈，看到这里，是不是有种特别的感觉？？？</p>
<p>没错了！！！这不就是Eureka服务注册中心的心跳机制类似么！</p>
<p>微服务注册中心采用心跳机制，隔一段时间去看看注册进自己的微服务有没有死亡。</p>
<p>如果已经死亡，不会立即清除其记录，会先搁一段时间。</p>
<p>害！！！技术原来很多都是相通的。越来越有意思了。</p>
<h2 id="本文小总结"><a href="#本文小总结" class="headerlink" title="本文小总结"></a>本文小总结</h2><p>TCP 还有很多知识点，我这里没有涉及到。比如 TCP 的拥塞控制 和 流量控制。（经典问题：TCP 是如何保证可靠传输的？）</p>
<p>其他的问题，后续慢慢补充。</p>
<p>学习是一个过程，没有一蹴而就、一步登天，先不要去想那么高深莫测的远方。冲吧！少年~</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></p>
<p><a href="">Java核心面试题整理</a></p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>ztranscript</li>
    <li><strong>本文链接：</strong><a href="https://ztranscript.github.io/2021/03/25/hi,TCP/index.html" title="https:&#x2F;&#x2F;ztranscript.github.io&#x2F;2021&#x2F;03&#x2F;25&#x2F;hi,TCP&#x2F;index.html">https:&#x2F;&#x2F;ztranscript.github.io&#x2F;2021&#x2F;03&#x2F;25&#x2F;hi,TCP&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul> 

        
  <nav class="nav">
    <a></a>
    <a href="/2021/03/25/Go/">Go<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-TCP-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-text">01 TCP 基本认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text">02 TCP 连接建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-TCP-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="toc-text">03 TCP 连接断开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">本文小总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-text">参考文章：</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/izhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>