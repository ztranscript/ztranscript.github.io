

<!DOCTYPE html>
<html lang="zh-CN" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>说说TCP可靠传输 - ztranscript</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="待办清单
✅ 糊涂窗口综合症
🔲 拥塞控制 之 快速...">
  <meta name="author" content="ztranscript">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/monokai-sublime.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/tomorrow-night-eighties.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: true,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '[object Object]',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'normal'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar" style="">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">说说TCP可靠传输</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">说说TCP可靠传输</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>三月 27, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>7293</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h2 id="待办清单"><a href="#待办清单" class="headerlink" title="待办清单"></a>待办清单</h2><ul>
<li>✅ 糊涂窗口综合症</li>
<li>🔲 拥塞控制 之 快速恢复算法</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我来了。</p>
<p>在上篇，我们聊了 TCP 的三次握手、四次挥手的相关知识。</p>
<p>这次我们来聊聊 TCP 的一些其他知识。</p>
<p>我们都知道，TCP 是一个可靠性的传输层协议，那么它是怎样保证可靠性的呢？</p>
<p>不卖关子了，正如我们大学计网所学的那样，TCP 依靠着 重传机制、滑动窗口、流量控制、拥塞控制来进行其可靠性传输。。。</p>
<p>这篇我们来聊聊这几个知识点。</p>
<p>如下图：（图片来自网络）</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616740319546-c7f76a7a-2c97-4224-bf46-12e30335b537.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<h2 id="1、重传机制"><a href="#1、重传机制" class="headerlink" title="1、重传机制"></a>1、重传机制</h2><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616813964786-9e09a9a7-637d-4992-8877-986894d0fd77.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>但是，在错综复杂的网络世界，并不一定能够像图中所示如此顺利的传输。很可能出现丢包现象！</p>
<p>由此，TCP 会采用重传机制来解决问题。</p>
<p>常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814222642-4f493172-738d-4ea1-85e4-68d56addb104.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<h4 id="Q：超时时间应该设置为多少？"><a href="#Q：超时时间应该设置为多少？" class="headerlink" title="Q：超时时间应该设置为多少？"></a>Q：超时时间应该设置为多少？</h4><p>我们先来看看图。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814317604-c3b7bbb1-44d6-49c0-93a5-704a06d4c28b.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814335312-911b3b46-1d62-4320-a423-1a005c8d4348.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814382493-fa61a20a-fdca-4054-b3cd-ca96c36f6579.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>一般来说，报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>所以，RTO 的计算方式并不是我们想象的那样简单，并非是发送一个包记时间为 <code>t0</code>，然后接收端再把这个 <code>ack</code> 回来时再记一个 <code>t1</code>，于是 <code>RTT = t1 – t0</code>。这只是一个采样，不能代表普遍情况。</p>
<p>具体的，可以翻阅文章末的链接。大佬的文章里有详细的描述。</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong></p>
<p>**<br>**</p>
<p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<p>**<br>**</p>
<p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814699461-836d17d7-ead4-40ca-abe0-25aab66bccff.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></p>
<p>**<br>**</p>
<p>由此，我们可以知道的是，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment 选择性确认）。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616814828984-254031bf-b9ff-447e-81ec-bc5ddcf7cee5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>如上图，三次同样的ACK，就会触发重传机制，然后发送方根据 SACK 信息发现，200-299这段信息丢失，于是重传时，只需要发送这段信息即可。</p>
<h3 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h3><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p>**<br>**</p>
<p>D-SACK的两个作用：</p>
<ul>
<li>ACK 丢包</li>
<li>网络延时</li>
</ul>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616815176362-b244a100-5760-4dfd-8458-1e60e41aca00.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>S-ACK通过 ACK + SACK信息告诉我们，哪段信息丢失了，需要重传。</p>
<p>这里的D-SACK则是告诉我们哪段信息重复接收了，只是接收方发回的ACK包丢失了罢了。</p>
<p><strong>原因就是，这里的ACK号已经到4000了，而SACK标识的是3000-3500，这样就能表明这是一个 D-SACK信息。</strong></p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616815186193-5239f811-0cf0-4f4f-8bf1-193947171951.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p><strong>「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></p>
<p>**<br>**</p>
<p>可见，D-SACK 有这么几个好处：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
</ul>
<ul>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
</ul>
<ul>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
<p><strong>感觉这一个重传机制还是有点东西的，比如这里的第二点和第三点，就有种私密传输（安全）的意味了！</strong></p>
<h2 id="2、滑动窗口"><a href="#2、滑动窗口" class="headerlink" title="2、滑动窗口"></a>2、滑动窗口</h2><p><strong>引入窗口概念的原因</strong></p>
<p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p>
<p>但是这种效率显然很低下，所以需要引入 <strong>窗口</strong> 来解决这个问题。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816456960-6514834a-56bb-4538-8280-73a01d560360.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，</p>
<p>必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816563760-0f03e15f-4d31-4cf1-a093-ea3812328693.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通话下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<h4 id="Q：窗口大小由哪一方决定的？"><a href="#Q：窗口大小由哪一方决定的？" class="headerlink" title="Q：窗口大小由哪一方决定的？"></a>Q：窗口大小由哪一方决定的？</h4><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的决定的。</p>
<h3 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h3><p>直接上图，好理解。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816700789-867406e7-73c4-46be-aaea-59df20503828.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816711143-96e7536f-6962-459d-9637-c3ec7d293fb0.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816717606-e7c7aaea-7b27-4d57-ba57-54aa84111fed.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p>
<p>这几张图比较好理解，这里就不额外阐述了。</p>
<h4 id="Q：程序是如何表示发送方的四个部分的呢？"><a href="#Q：程序是如何表示发送方的四个部分的呢？" class="headerlink" title="Q：程序是如何表示发送方的四个部分的呢？"></a>Q：程序是如何表示发送方的四个部分的呢？</h4><p>TCP 滑动窗口方案使用三个指针来表示！！！</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816824720-6fb8b85e-6e20-4661-a9e7-68ec4ab64245.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code>大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<p><strong>可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</strong></p>
<p>**<br>**</p>
<p>**<br>**</p>
<h3 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h3><p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616816889721-499268ca-0cc4-43c9-a5a5-d7a73285036c.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code>大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<h4 id="Q：接收窗口和发送窗口的大小是相等的吗？"><a href="#Q：接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="Q：接收窗口和发送窗口的大小是相等的吗？"></a>Q：接收窗口和发送窗口的大小是相等的吗？</h4><p>约等于相等。</p>
<p>由于网络延迟，可能导致当接收方告诉发送方，此时可以改变窗口大小的包不会立马传输到发送方。这时候会有一段时间，两者并不相等。</p>
<h2 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p>**<br>**</p>
<p>来看例子，下图中假设：</p>
<ul>
<li>客户端是接收方，服务端是发送方</li>
<li>假设接收窗口和发送窗口相同，都为 <code>200</code></li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li>
</ul>
<p>**<br>**</p>
<p><strong><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616817141025-28f51cbf-5be7-49ed-906e-3b888ca57132.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></strong></p>
<p>**<br>**</p>
<p>上图有一个点需要提出来，第4步，此时服务端发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法在继续发送数据。</p>
<p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p>
<h4 id="Q：那操作系统的缓冲区，是如何影响发送窗口和接收窗口的？"><a href="#Q：那操作系统的缓冲区，是如何影响发送窗口和接收窗口的？" class="headerlink" title="Q：那操作系统的缓冲区，是如何影响发送窗口和接收窗口的？"></a>Q：那操作系统的缓冲区，是如何影响发送窗口和接收窗口的？</h4><p><strong>情景一：</strong></p>
<p>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。</p>
<p>假定：</p>
<ul>
<li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 <code>360</code>；</li>
<li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li>
</ul>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616817597181-00cd3346-9b2d-42b8-842b-20f0618db92e.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p>
<p><strong>情景二：</strong></p>
<p>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616817671620-094ad656-f68a-484e-99ee-454eed0bb0d5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>上图中，发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p>
<p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况。</strong></p>
<p>**<br>**</p>
<p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<p>**<br>**</p>
<h3 id="窗口关闭潜在的危险"><a href="#窗口关闭潜在的危险" class="headerlink" title="窗口关闭潜在的危险"></a>窗口关闭潜在的危险</h3><p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616817849230-d5efc33f-7211-47cd-be0e-acf294a1736b.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>很明显，如果需要恢复窗口的包在网络传输中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<h4 id="Q：TCP-是如何解决窗口关闭时，潜在的死锁现象呢？"><a href="#Q：TCP-是如何解决窗口关闭时，潜在的死锁现象呢？" class="headerlink" title="Q：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？"></a>Q：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</h4><p>我们前面提到过，TCP 可靠传输的关键点，在于ACK确认包机制。而ACK确认，会有丢包现象，那么引入了 超时 的概念，超时就会重传。</p>
<p>这里的话，感觉思想差不多。</p>
<p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616818124711-801534ba-4ead-4a6a-bb8a-261b23e57591.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探查探测的次数一般为 3 此次，每次次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h3 id="啥叫糊涂窗口综合症？"><a href="#啥叫糊涂窗口综合症？" class="headerlink" title="啥叫糊涂窗口综合症？"></a>啥叫糊涂窗口综合症？</h3><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p>
<p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p>
<p>要知道，TCP + IP 头有40个字节，如果仅仅为了传输那么几个字节，这样的操作未免太不经济了些。</p>
<p>举个例子，考虑如下场景：</p>
<ul>
<li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li>
<li>在下一个发送方的 TCP 段到达之前，应用程序<br>  还从缓冲区中读取了 40 个额外的字节；</li>
</ul>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616894679361-63a67da2-035e-472c-a8d2-346be35f8bf5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span>   </p>
<p>仔细看图中的表述，不难发现，越到后面，<strong>窗口</strong>越来越小，并且发送的数据也越来越小<strong>。</strong></p>
<p>**<br>**</p>
<p>此时的现象是：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>那么解决糊涂窗口综合症，自然是如何解决上面这两个问题。</p>
<h4 id="Q：怎么让接收方不通告小窗口？"><a href="#Q：怎么让接收方不通告小窗口？" class="headerlink" title="Q：怎么让接收方不通告小窗口？"></a>Q：怎么让接收方不通告小窗口？</h4><p>接收方通常的策略如下:</p>
<p>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
<h4 id="Q：怎么让发送方避免发送小数据？"><a href="#Q：怎么让发送方避免发送小数据？" class="headerlink" title="Q：怎么让发送方避免发送小数据？"></a>Q：怎么让发送方避免发送小数据？</h4><p>发送方通常的策略如下：</p>
<p>使用<strong>延时处理</strong>的思想，只有满足了如下条件的一条才能发送数据：</p>
<ul>
<li>要等到窗口大小 &gt;= <code>MSS</code> 或是 数据大小 &gt;= <code>MSS</code></li>
<li>收到之前发送数据的 <code>ack</code> 回包</li>
</ul>
<p>在没有满足任一条件之前，发送方就一直在囤积数据，这样就避免了小数据的频繁发送。</p>
<p>不过，如果是某些交互性很强的程序，则不适合采用此种方案。</p>
<p>**<br>**</p>
<h2 id="4、拥塞控制"><a href="#4、拥塞控制" class="headerlink" title="4、拥塞控制"></a>4、拥塞控制</h2><h4 id="Q：为什么有了流量控制，还需要拥塞控制？"><a href="#Q：为什么有了流量控制，还需要拥塞控制？" class="headerlink" title="Q：为什么有了流量控制，还需要拥塞控制？"></a>Q：为什么有了流量控制，还需要拥塞控制？</h4><p>前面的流量控制的主要目的，是为了解决接收方、发送方两者之间的数据传输问题。</p>
<p>而网络是一个共享的世界，说不定某刻网络由于其他主机之间的通信而变得十分拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>**<br>**</p>
<p>所以，TCP 不能忽略网络上发生的事，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<p>**<br>**</p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<h4 id="Q：什么是拥塞窗口？它与发送窗口是什么关系？"><a href="#Q：什么是拥塞窗口？它与发送窗口是什么关系？" class="headerlink" title="Q：什么是拥塞窗口？它与发送窗口是什么关系？"></a>Q：什么是拥塞窗口？它与发送窗口是什么关系？</h4><p>拥塞窗口cwnd 是发送方维护的一个状态变量，它根据网络的情况变化。</p>
<p>前面提到，发送窗口swnd 和 接收窗口 rwnd 大约是等于的关系。 那么在加入 cwnd后，此时三者的关系为：</p>
<p><strong>swnd = min（cwnd，rwnd）。</strong></p>
<p>**<br>**</p>
<h4 id="Q：怎么知道当前网络发生了拥堵的呢？"><a href="#Q：怎么知道当前网络发生了拥堵的呢？" class="headerlink" title="Q：怎么知道当前网络发生了拥堵的呢？"></a>Q：怎么知道当前网络发生了拥堵的呢？</h4><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<p>**<br>**</p>
<h4 id="Q：拥塞控制有哪些算法呢？"><a href="#Q：拥塞控制有哪些算法呢？" class="headerlink" title="Q：拥塞控制有哪些算法呢？"></a>Q：拥塞控制有哪些算法呢？</h4><p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616895777235-64bbedc1-a05c-43a8-9721-7c4c2fc0371a.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>**<br>**</p>
<p>TCP 刚建立连接的时候，会一点点的加大窗口大小，这么做的目的是不给网络通道中添堵，谁知道此刻是个什么情况呢？你如果一来就大数据量的传输，岂不是 “害人害己”？？？</p>
<h4 id="Q：慢启动总得有个头吧？"><a href="#Q：慢启动总得有个头吧？" class="headerlink" title="Q：慢启动总得有个头吧？"></a>Q：慢启动总得有个头吧？</h4><p>类似于 HashMap 容器中可存储的容器个数有个 <strong>threshold</strong> 阈值。</p>
<p>这里也有一个阈值，叫做<strong>ssthresh</strong>（slow start threshold）慢启动门阀。</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616896039624-a31cfe80-2ee3-4a09-8aa0-1e1272f3a956.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<p>**<br>**</p>
<p>但是这么一直涨下去也不是个办法，到后面极有可能发生网络拥堵，就会产生丢包现象，也就是会对包进行超时重传。</p>
<p>这个时候就进入了「拥塞发生算法」。</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<h4 id="超时重传-1"><a href="#超时重传-1" class="headerlink" title="超时重传"></a>超时重传</h4><p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616896327962-2598d4d0-2d35-4650-ad5c-4c6af46ca5c9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<p>此种算法结果是：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<p>好比 “一夜回到解放前”。这种做法似乎有些激进了哈，反应也很强烈，会造成网络卡顿。</p>
<h4 id="快速重传-1"><a href="#快速重传-1" class="headerlink" title="快速重传"></a>快速重传</h4><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<p><img    class="lazyload" data-original="https://gitee.com/Kyrie98/blog-img/raw/master/img/1616896635866-5cfa7057-00d3-47cc-bcda-69f7a1be3825.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP/IP协议栈 巨复杂，内容是在学习了大佬的文章写的。</p>
<p>看到过大佬一句话，亘古不变的是技术的本质。所以啊，打好基础十分关键。</p>
<h2 id="站在巨人的肩膀"><a href="#站在巨人的肩膀" class="headerlink" title="站在巨人的肩膀"></a>站在巨人的肩膀</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA">你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了</a></p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>ztranscript</li>
    <li><strong>本文链接：</strong><a href="https://ztranscript.github.io/2021/03/27/%E8%AF%B4%E8%AF%B4TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/index.html" title="https:&#x2F;&#x2F;ztranscript.github.io&#x2F;2021&#x2F;03&#x2F;27&#x2F;%E8%AF%B4%E8%AF%B4TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&#x2F;index.html">https:&#x2F;&#x2F;ztranscript.github.io&#x2F;2021&#x2F;03&#x2F;27&#x2F;%E8%AF%B4%E8%AF%B4TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/03/31/Java%20%E6%B3%A8%E8%A7%A3/"><i class="iconfont iconleft"></i>Java 注解</a>
    <a href="/2021/03/25/hi,TCP/">hi,TCP<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95"><span class="toc-text">待办清单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-text">1、重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SACK"><span class="toc-text">SACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-SACK"><span class="toc-text">D-SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">2、滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">发送方的滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">接收方的滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">3、流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E6%BD%9C%E5%9C%A8%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-text">窗口关闭潜在的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%A5%E5%8F%AB%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87%EF%BC%9F"><span class="toc-text">啥叫糊涂窗口综合症？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">4、拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-text">拥塞发生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-text">快速恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80"><span class="toc-text">站在巨人的肩膀</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="http://wpa.qq.com/msgrd?v=3&uin=&site=qq&menu=yes"
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/ztranscript "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>